---
title: 'Lasso and Elastic-Net Regularized Generalized Linear Models'
subtitle: 'Cox Model'
author: "Chunyi Wu and Andrzej Galecki"
date: "`r as.character(Sys.Date(), format = '%A %B %d, %Y')`"
output:
  rmdformats::readthedown: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, data, echo=FALSE, message=FALSE, warning=FALSE}
if (!require('pacman')) install.packages('pacman', repos = "http://cran.us.r-project.org")
library(pacman)

pacman::p_load(
  readxl,       # load excel file
  glmnet,       # Lasso and Elastic-Net Regularized Generalized Linear Models
  rmdformats,   # rmd formats
  rmarkdown,    # rmarkdown
  here,         # File locator
  skimr,        # get overview of data
  tidyverse,    # data management + ggplot2 graphics 
  janitor,      # adding totals and percents to tables
  flextable,    # format the output table
  gtsummary,    # calculate summary statistics and format the results
  sjPlot,       # correlation matrix
  purrr,        # enhances Râ€™s functional programming (FP) toolki 
  tidyr,        #Tools to help to create tidy data
  ggplot2,       #Plot the results
  glmnetUtils   #Glmnet models for multiple alpha
  )
```

# Prepare data/matrices 

```{r, Unstardized1, echo=TRUE, message=FALSE, warning=FALSE}
#read the data that is stored under the data folder
scrambled<-readRDS(file = "./Data/scrambled.rds")

#set seed to ensure reproducible results
set.seed(46)

#select variables for unadjusted model
data <- scrambled  %>% select("KIM1.npx","SYND1.npx","IL.1RT1.npx","WFDC2.npx","CD27.npx", "TNFRSF10A.npx","LAYN.npx","PVRL4.npx","EDA2R.npx","TNFRSF4.npx","GFR_alpha_1_npx","TNF.R1.npx","PI3_npx", "EFNA4.npx","TNF.R2.npx" ,"DLL1.npx" ,"TNFRSF6B.npx", "CD160.npx","EPHA2.npx","RELT.npx","LTBR.npx","time","status") 

#drop any records with NA
data_drop_na <- data %>% drop_na()    

#Total sample size
nrow(data_drop_na)

#includes all proteins after excluding missing data
x <- data.matrix(data_drop_na[,c("KIM1.npx","SYND1.npx","IL.1RT1.npx","WFDC2.npx","CD27.npx", "TNFRSF10A.npx","LAYN.npx","PVRL4.npx","EDA2R.npx","TNFRSF4.npx","GFR_alpha_1_npx","TNF.R1.npx","PI3_npx", "EFNA4.npx","TNF.R2.npx" ,"DLL1.npx" ,"TNFRSF6B.npx", "CD160.npx","EPHA2.npx","RELT.npx","LTBR.npx")])

#select follow-up time and status
y <- data.matrix(data_drop_na[,c("time","status")])
```

# glmnet for a given $\alpha$

## Fit cox regression glmnet for a given $\alpha$

* Mixing (hyper) parameter $\alpha$ by default is equal to $1$ (lasso regression)


```{r, Unstardized2, echo=TRUE, message=FALSE, warning=FALSE}
#fit the unadjusted cox regression model
pfit <- glmnet(x, y, family = "cox")
```

##  Unadjusted Cox Regression Model Coefficient Plot

```{r, Unstardized_plot, echo=TRUE, message=FALSE, warning=FALSE}
plot(pfit, label = TRUE) 
```
"Each curve corresponds to a variable. It shows the path of its coefficient against the ${\ell}_1$-norm of the whole 
coefficient vector as $\lambda$ varies. The axis above indicates the number of nonzero coefficients at the current $\lambda$, 
which is the effective degrees of freedom (df) for the lasso."

source: ("https://glmnet.stanford.edu/articles/glmnet.html")


# glmnetUtils Glmnet models for multiple alpha 

* We use cross-validation to select a value for $\alpha$.
* The idea of "explicitly control the fold" is implemented in
`glmnetUtils` package

source: (https://glmnet.stanford.edu/articles/glmnet.html)

```{r glmnetUtils}

set.seed(46)
alphv <- seq(0, 1, len = 11)^3
cva_pfit <- cva.glmnet(x=x,y=y,family = "cox", alpha = alphv)
minlossplot(cva_pfit)
```

Extract the best parameters from cva.glmnet object

```{r get_best_params}
# Extract the best parameters from cva.glmnet object.
get_model_params <- function(fit) {
  alpha <- fit$alpha
  lambdaMin <- sapply(fit$modlist, `[[`, "lambda.min")
  lambdaSE <- sapply(fit$modlist, `[[`, "lambda.1se")
  error <- sapply(fit$modlist, function(mod) {min(mod$cvm)})
  best <- which.min(error)
  data.frame(alpha = alpha[best], lambdaMin = lambdaMin[best],
             lambdaSE = lambdaSE[best], eror = error[best])
}

get_model_params(cva_pfit)
```

Cox regression coefficients using the best parameters

```{r get_best_coef}
coef(cva_pfit, s = get_model_params(cva_pfit)$lambdaMin, alpha=get_model_params(cva_pfit)$alpha)
```

Save cva.object for post-processing

```{r save-cva_pfit}
save(cva_pfit, file = "./save/31Cox-Reg1-save1.Rdata")
```



#  Cross-validation of cox regression model (Optional)

## Unadjusted Cox Regression Model 
##   - coefficient plot
###  Unadjusted Cross-Validated Cox Regression Model Coefficient Plot
```{r, Unstardized_cv_plot, echo=TRUE, message=FALSE, warning=FALSE}
#fit the cross-validatedmodel
cvfit <- cv.glmnet(x, y, family = "cox")

plot(pfit, label = TRUE) 
```

"This plots the cross-validation curve (red dotted line) along with upper and lower standard deviation curves
along the $\lambda$ sequence (error bars). Two special values along the $\lambda$ sequence are indicated by the 
vertical dotted lines. `lambda.min` is the value of $\lambda$ that gives minimum mean cross-validated error, 
while `lambda.1se` is the value of $\lambda$ that gives the most regularized model such that the cross-validated 
error is within one standard error of the minimum."

source: ("https://glmnet.stanford.edu/articles/glmnet.html")

##   - minimal lambda value

###  Unadjusted Cross-Validated Cox Regression Coefficients using the minimal lambda value 
```{r, Unstardized_cv_min, echo=TRUE, message=FALSE, warning=FALSE}
#get the minimal lambda value (value of lambda that gives minimum cvm)
cvfit$lambda.min
# Cross-validated cox regression Model using the minimal lambda
coef(cvfit, s = "lambda.min")
```

##   - lambda.lse
####  Unadjusted Cross-Validated Cox Regression Coefficients using lambda.lse
```{r, Unstardized_cv_lse, echo=TRUE, message=FALSE, warning=FALSE}
#largest value of lambda such that error is within 1 standard error of the minimum.
cvfit$lambda.lse
# Cross-validated Cox Regression Model using the lambda.lse
coef(cvfit)
```

## Adjusted Cox Regression Model 

### Adjusted Cox Regression Model (adjusting for Baseline HbA1c, ACR, eGFR)
```{r, Adjusted, echo=TRUE, message=FALSE, warning=FALSE}

#select variables for adjusted model
data2 <- scrambled  %>% select("KIM1.npx","SYND1.npx","IL.1RT1.npx","WFDC2.npx","CD27.npx", "TNFRSF10A.npx","LAYN.npx","PVRL4.npx","EDA2R.npx","TNFRSF4.npx","GFR_alpha_1_npx","TNF.R1.npx","PI3_npx", "EFNA4.npx","TNF.R2.npx" ,"DLL1.npx" ,"TNFRSF6B.npx", "CD160.npx","EPHA2.npx","RELT.npx","LTBR.npx","time","status","BL_eGFR","log10_B_HBA1C_PRC","log10_DU_ACR") 

#drop any records with NA
data_drop_na2 <- data2 %>% drop_na()    

#Total sample size
nrow(data_drop_na2)

#includes all proteins after excluding missing data
x2 <- data.matrix(data_drop_na2[,c("KIM1.npx","SYND1.npx","IL.1RT1.npx","WFDC2.npx","CD27.npx", "TNFRSF10A.npx","LAYN.npx","PVRL4.npx","EDA2R.npx","TNFRSF4.npx","GFR_alpha_1_npx","TNF.R1.npx","PI3_npx", "EFNA4.npx","TNF.R2.npx" ,"DLL1.npx" ,"TNFRSF6B.npx", "CD160.npx","EPHA2.npx","RELT.npx","LTBR.npx","BL_eGFR","log10_B_HBA1C_PRC","log10_DU_ACR")])

#select follow-up time and status
y2 <- data.matrix(data_drop_na2[,c("time","status")])

#fit the unadjusted cox regression model
pfit2 <- glmnet(x2, y2, family = "cox")

```

##   - coefficient plot
####  Adjusted Cox Regression Model Coefficient Plot
```{r, Adjusted_plot, echo=TRUE, message=FALSE, warning=FALSE}
plot(pfit2, label = TRUE) 
```

##   - cross-validated cox regression model
####  Adjusted Cross-Validated Cox Regression Model Coefficient Plot
```{r, Adjusted_cv_plot, echo=TRUE, message=FALSE, warning=FALSE}
#fit the cross-validatedmodel
cvfit2 <- cv.glmnet(x2, y2, family = "cox")

plot(pfit2, label = TRUE) 
```

##   - minimal lambda value
####  Adjusted Cross-Validated Cox Regressionn Coefficients using minimal lambda value
```{r, Adjusted_cv_min, echo=TRUE, message=FALSE, warning=FALSE}
#get the minimal lambda value (value of lambda that gives minimum cvm)
cvfit2$lambda.min
# Cross-validated cox Regression Model using the minimal lambda
coef(cvfit2, s = "lambda.min")
```

##   - lambda.lse
####  Adjusted Cross-Validated Cox Regression Coefficients using lambda.lse
```{r, Adjusted_cv_lse, echo=TRUE, message=FALSE, warning=FALSE}
#largest value of lambda such that error is within 1 standard error of the minimum.
cvfit2$lambda.lse
# Cross-validated Cox Regression Model using the lambda.lse
coef(cvfit2)
```