---
title: 'Regularized for Cox Regression Model M2'
author: "Chunyi Wu and Andrzej Galecki"
date: "`r as.character(Sys.Date(), format = '%A %B %d, %Y')`"
output:
  rmdformats::readthedown:
    lightbox: true
    use_bookdown: true 
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, comment="#>")
```

```{r, data, echo=FALSE, message=FALSE, warning=FALSE}
if (!require('pacman')) install.packages('pacman', repos = "http://cran.us.r-project.org")
library(pacman)

pacman::p_load(
  readxl,       # load excel file
  glmnet,       # Lasso and Elastic-Net Regularized Generalized Linear Models
  rmdformats,   # rmd formats
  rmarkdown,    # rmarkdown
  here,         # File locator
  skimr,        # get overview of data
  tidyverse,    # data management + ggplot2 graphics 
  janitor,      # adding totals and percents to tables
  flextable,    # format the output table
  gtsummary,    # calculate summary statistics and format the results
  sjPlot,       # correlation matrix
  purrr,        # enhances R functional programming (FP) toolki 
  tidyr,        #Tools to help to create tidy data
  ggplot2,      #Plot the results
  glmnetUtils,  #Glmnet models for multiple alpha
  coefplot,     # Plotting Model Coefficients
  survival,     #survival model 
  tidymodels,   #for modeling and machine learning using tidyverse principles
  survivalROC   #survivalROC
  )
```
```{r utilsag}
if (!require('utilsag')) devtools::install_github("agalecki/utilsag") #, ref = "version-0.1.1")
library(utilsag)
```

# Introduction

In this report we consider Cox regression model M2 for the  time-to-event `time` variable. Originally this 
variable was named `FU_TIME`.  

`status` (0/1) variable, originally named `CASE_CONTROL`, is coded 0 for Controls (i.e., ESKD event has not occurred), and 1 for Cases (i.e., event has occurred)

* M2 :Contains 21 proteins and Baseline HbA1c, log10(ACR), BL_eGFR, SEX, and AGE_TL(Baseline Age) as candidate predictors


## Auxiliary functions

```{r  pred-coxnet}
#' Predicted values for _coxnet model
#'
#' Invokes `predict._coxnet()` to calculate different types of predicted values for _coxnet model
#'
#' @export
pred_coxnet <- function(model_fit, new_data, 
                       time_var = time, status_var = status,
                       time_points = NULL){
  lin_pred <- predict(model_fit, new_data, type = "linear_pred", increasing = FALSE)
  time_pred <- predict(model_fit, new_data, type = "time") 
  tmp <- time_points
  condt <- !is.null(tmp) && is.numeric(tmp) && length(tmp) > 0
  survprob <- NULL
  if (condt) survprob <- predict(model_fit, new_data, type = "survival", time = tmp)
  tvar <- as.character(substitute(time_var))
  svar <- as.character(substitute(status_var))
  cts  <- c(tvar, svar)
  res <- new_data %>% select(all_of(cts)) %>% cbind(lin_pred, time_pred)
  if (condt) res <- cbind(res, survprob)
  as_tibble(res)
}

```

## Data prep

Data are prepared for Cox regression.        

```{r, prepare-data, echo=TRUE, message=FALSE, warning=FALSE}
#read the data that is stored under the data folder

dt <- read_excel("./Data/data_example.xlsx")

dt <- dt  %>% rename(time = FU_TIME, status = CASE_CONTROL) %>% 
  mutate(log10_DU_ACR = log10(DU_ACR))  %>% filter(time>0)

dim(dt) # Number of rows and columns in the input data

# variables used in Cox regression model
prot_npx <- c("KIM1.npx","SYND1.npx","IL.1RT1.npx",   "WFDC2.npx", "CD27.npx",
              "TNFRSF10A.npx","LAYN.npx","PVRL4.npx", "EDA2R.npx","TNFRSF4.npx",
              "GFR_alpha_1_npx","TNF.R1.npx","PI3_npx", "EFNA4.npx","TNF.R2.npx" ,
              "DLL1.npx", "TNFRSF6B.npx", "CD160.npx", "EPHA2.npx","RELT.npx",
              "LTBR.npx") 
surv_vars <-  c("time", "status")
clin_vars <- c("BL_eGFR","B_HBA1C_PRC","log10_DU_ACR","SEX","AGE_TL")
```


* Data preparation

```{r data-prep}
vars <- c(surv_vars,  prot_npx, clin_vars) # <--
data <- dt  %>% select(all_of(vars)) 

#drop any records with NA
dim(data)         

#drop any records with NA
data_drop_na <- data %>% drop_na()    

#Total sample size
nrow(data_drop_na)

#includes all proteins after excluding missing data
x <- data.matrix(data_drop_na[,c(prot_npx, clin_vars)])

#select follow-up time and status
y <- data.matrix(data_drop_na[,c("time","status")])
ySurv <- survival::Surv(y[,"time"], y[,"status"])
```

Create folds

```{r foldid}
set.seed(1234)
foldid <- sample(1:10, size = nrow(data_drop_na), replace=TRUE)

```

# glmnet  



## glmnet ($\alpha=0$)

## glmnet fit ($\alpha=0$)

```{r glmnet-pfit, echo=TRUE, message=FALSE, warning=FALSE}
#fit the cox regression model
pfit <- glmnet(x, ySurv, family = "cox", alpha=0)
```

## Extracting info from glmnet fit

### Coefficient plots

* Cox Regression Model Coefficient Plot

```{r, pfit_plot, echo=TRUE, message=FALSE, warning=FALSE}
plot(pfit, label = TRUE) 
```


# cv.glmnet

## cv.glmnet ($\alpha=0$)

### C-V coefficient plot ($\alpha=0$)


* Cross-Validated Cox Regression Model Coefficient Plot

```{r, cv_plot-a0, echo=TRUE, message=FALSE, warning=FALSE}
#fit the cross-validatedmodel
cvfit_a0 <- cv.glmnet(x, ySurv, family = "cox", alpha=0, foldid = foldid)
plot(cvfit_a0, label = TRUE) 
```


### Extract info from C-V ($\alpha=0$)


* Coefficients for selected $\lambda$s

Cross-Validated Cox Regressionn Coefficients using `lambda.min` value

```{r, cv-min-a0, echo=TRUE, message=FALSE, warning=FALSE}
#get the minimal lambda value (value of lambda that gives minimum cvm)
(lmbda_min_a0 <- cvfit_a0$lambda.min)

# Express on natural log scale
log(lmbda_min_a0)
# Cross-validated Cox Regression Model using the minimal lambda
coef(cvfit_a0, s = "lambda.min")
```

* Cross-Validated Cox Regression Coefficients using `lambda.1se`
* largest value of lambda such that error is within 1 standard error of the minimum.

```{r, cv-lse-a0, echo=TRUE, message=FALSE, warning=FALSE}
(lmbda_1se_a0 <- cvfit_a0$lambda.1se)

# Express on natural log scale
log(lmbda_1se_a0)

coef(cvfit_a0, s = "lambda.1se")
```

???

## cv.glmnet ($\alpha=1$)

### C-V coefficient plot ($\alpha=1$)


* Cross-Validated Cox Regression Model Coefficient Plot

```{r, cv_plot-a1, echo=TRUE, message=FALSE, warning=FALSE}

#fit the cross-validatedmodel
cvfit_a1 <- cv.glmnet(x, ySurv, family = "cox", alpha=1, foldid = foldid)
plot(cvfit_a1, label = TRUE) 
```


### Extract info from C-V ($\alpha=1$)


* Coefficients for selected $\lambda$s

Cross-Validated Cox Regressionn Coefficients using `lambda.min` value

```{r, cv-min-a1, echo=TRUE, message=FALSE, warning=FALSE}
#get the minimal lambda value (value of lambda that gives minimum cvm)
(lmbda_min_a1 <- cvfit_a1$lambda.min)

# Express on natural log scale
log(lmbda_min_a1)
# Cross-validated Cox Regression Model using the minimal lambda
coef(cvfit_a1, s = "lambda.min")
```

* Cross-Validated Cox Regression Coefficients using `lambda.1se`
* largest value of lambda such that error is within 1 standard error of the minimum.

```{r, cv-lse-a1, echo=TRUE, message=FALSE, warning=FALSE}
(lmbda_1se_a1 <- cvfit_a1$lambda.1se)

# Express on natural log scale
log(lmbda_1se_a1)

coef(cvfit_a1, s = "lambda.1se")
```

# glmnetUtils

* Glmnet models for multiple alpha 
* We use cross-validation to tune hyperparameter $\alpha$.
* The idea of "explicitly control the fold" is implemented in `glmnetUtils` package
* The cva.glmnet function does simultaneous cross-validation for both the $\alpha$ and $\lambda$ parameters in an elastic net model.

source: (https://glmnet.stanford.edu/articles/glmnet.html)

```{r glmnetUtils}

alphv <- seq(0, 1, len = 11)^3
cva_pfit <- cva.glmnet(x=x,y=ySurv,family = "cox", alpha = alphv, foldid = foldid)
minlossplot(cva_pfit)
```

Extract optimal (hyper)parameters from `cva.glmnet` object

```{r get_best_params}

(pfit_params <- get_cvaglmnet_params(cva_pfit))

a_opt <- pfit_params[["alpha"]]
lmbda_opt <- pfit_params[["lambdaMin"]]
```

Cox regression coefficients using the best combination of (hyper)parameters

```{r get_best_coef}

coef(cva_pfit, s = lmbda_opt, alpha = a_opt)
```
## Plotting survival curves for optimal model

See examples at: https://glmnet.stanford.edu/reference/survfit.coxnet.html

Notes: 

* `survfit` computes the predicted survivor function for a Cox PH model with elastic net penalty.
* the design matrix x and response ySurv used to fit the model need to be passed to `survfit` function

* Step 1: Fit the glmnet model to original data (stored in x2 and y2Surv objects) using optimal alpha.
* Note: Resulting object `pfit_aopt` contains models for multiple lambdas. 

```{r pfit2_a-object}
pfit_aopt <- glmnet(x, ySurv, family = "cox", alpha= a_opt)
```

```{r surv2-plot}
# survfit object for penalized Cox model
sfx <- survival::survfit(pfit_aopt, s = lmbda_opt, x = x, y = ySurv)
plot(sfx)
```

Note that the same plot can be obtained using the code below.

```{r surv-plot-mean}
xmean <- apply(x, 2, mean)
sfm <- survival::survfit(pfit_aopt, s = lmbda_opt, x = x, y = ySurv, newx = xmean)
# plot(sfm)
```


# Model Performance

This section should be considered as an illustration only, because the `glmnet` model
performance is assessed using training data. For this reason performance of the model
is too optimistic.


## Preparatory steps

* Step 1.  Object `pfit_aopt` contains model fits for optimal alpha. It was created earlier in this document 
It contains model fits for multiple lambdas. 


Step 2: Prepare test data 

```{r Prepare-test-data}
dim(data_drop_na)
test_rows <- 1:nrow(data_drop_na) # Select rows for testing. Possibly all rows in data_drop_na.
x_test <- x[test_rows,]
y_test <- y[test_rows,]
ySurv_test <- survival::Surv(y_test[,"time"], y_test[,"status"] )

data_test <- data_drop_na[test_rows, ]
range(data_test$time)
```

Step 3: Calculate predicted values for test data

```{r calc-pred2}
predM_lpmtx <- predict(pfit_aopt, newx = x_test, type = "link") # Matrix
predM_lp <- as.vector(predict(pfit_aopt, newx = x_test, type = "link", s = lmbda_opt))
summary(predM_lp)
```

## Predictive performance 

Predictive performance of optimal model 

### C-index

Ref: Harrel Jr, F. E. and Lee, K. L. and Mark, D. B. (1996) Tutorial in biostatistics:
multivariable prognostic models: issues in developing models, evaluating assumptions 
and adequacy, and measuring and reducing error, _Statistics in Medicine_, 15, pages 361-387.


```{r C-index-Mod}
apply(predM_lpmtx, 2, Cindex, y = ySurv_test) # Multiple lambda
Cindex(predM_lp, ySurv_test)                  # For optimal lambda
```

### Time-dependent ROC

* source: (https://datascienceplus.com/time-dependent-roc-for-survival-prediction-models-in-r)


```{r surv-roc}
dataM_test <- data_test
                
## Augment `dataM2_test` with linear predictor
 dataM_test$predM_lp <- predM_lp

# Evaluate every 2.5 years
 
tx <- 2.5* c(2,3,4,5,6) # ROC time points

survROC_lp <- create_survivalROC_data(tx, dataM_test, predM_lp)
 
# survROC_lp %>% print (n=100)
```

* Plot Time-dependent ROC every 2.5 years

```{r surv-roc-plot}
## Plot Time-dependent ROC every 2.5 years
plot_timedep_ROC(survROC_lp) 
```


* Save `cva_pfit` object for post-processing

```{r save-cva_pfit2_M2}

save(cva_pfit, file = "./save/3M2_Cox-save1.Rdata")
```

# Tidymodels

Fit optimal models using tidymodels
Based on (https://parsnip.tidymodels.org/reference/details_proportional_hazards_glmnet.html)

```{r tidy-libs}
library(survival)
library(censored)
library(dplyr)
library(tidyr)
```


## Model fits 

Create `mod_all` object.

```{r tidy-Mod-all}
# Model for all alpha
mod_all <- map(alphv, function(a){
  proportional_hazards(penalty = tune(), mixture = a) %>% 
  set_engine("glmnet") %>% 
  fit(Surv(time, status) ~ ., data = data_drop_na)
})
length(mod_all)
tmp <- mod_all[[2]]
class(tmp)
```

* Create `mod_opt` object

```{r tidy-Mod-opt}
a_opt
lmbda_opt

mod_opt <- 
  proportional_hazards(penalty = lmbda_opt, mixture = a_opt) %>% 
  set_engine("glmnet") %>% 
  fit(Surv(time, status) ~ ., data = data_drop_na)
class(mod_opt)
```

# Tidy assessment


Create tibble with predicted values for M2:

* Linear predictor (`.pred_linear_pred`)
* Survival time (`.pred_time`)
* Survival probabilities at selected time points (`.pred`)

```{r  pred-coxnet-mod-opt}
tst_rows <- 1:nrow(data_drop_na) # Select rows for testing. Possibly all rows in data_drop_na2.
dataM_test <- data_drop_na[tst_rows, ]

pred_M <- pred_coxnet(mod_opt, dataM_test, time_points = c(5,10))
pred_M

pred_M %>% unnest(.pred)

summ_M <- pred_M %>%
                summarize(Cindex = Cindex(.pred_linear_pred, Surv(time, status)))
summ_M$Cindex


tx <- 2.5* c(2,3,4,5,6)    # ROC time points 
survROC_data <- create_survivalROC_data(tx, pred_M, .pred_linear_pred)

## Plot Time-dependent ROC every 2.5 years
plot_timedep_ROC(survROC_data) 
```



* save tidy objects

```{r save-tidy}
save(mod_all, mod_opt, alphv, file ="./save/3M2_Cox-save2.Rdata")
```

