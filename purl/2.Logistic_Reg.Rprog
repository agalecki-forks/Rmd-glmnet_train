## ----setup, include=FALSE-----------------------------------------------------
knitr::opts_chunk$set(echo = TRUE)


## ---- data, echo=FALSE, message=FALSE, warning=FALSE--------------------------
if (!require('pacman')) install.packages('pacman', repos = "http://cran.us.r-project.org")
library(pacman)

pacman::p_load(
  readxl,       # load excel file
  glmnet,       # Lasso and Elastic-Net Regularized Generalized Linear Models
  rmdformats,   # rmd formats
  rmarkdown,    # rmarkdown
  here,         # File locator
  skimr,        # get overview of data
  tidyverse,    # data management + ggplot2 graphics 
  janitor,      # adding totals and percents to tables
  flextable,    # format the output table
  gtsummary,    # calculate summary statistics and format the results
  sjPlot,       # correlation matrix
  purrr,        # enhances Râ€™s functional programming (FP) toolki 
  tidyr,        #Tools to help to create tidy data
  ggplot2       #Plot the results
  )


## ---- Unstardized, echo=TRUE, message=FALSE, warning=FALSE--------------------
#read the data that is stored under the data folder

####scrambled<-readRDS(file = "./Data/scrambled.rds")

scrambled=readxl::read_excel("./Data/jnpx_scrambled_053122.xlsx", na = "", guess_max = 1000)
scrambled <- scrambled  %>% mutate(log10_B_HBA1C_PRC=log10(B_HBA1C_PRC),log10_DU_ACR=log10(DU_ACR))
  

#set seed to ensure reproducible results
set.seed(46)

#select variables for unadjusted model
data <- scrambled  %>% select("KIM1.npx","SYND1.npx","IL.1RT1.npx","WFDC2.npx","CD27.npx", "TNFRSF10A.npx","LAYN.npx","PVRL4.npx","EDA2R.npx","TNFRSF4.npx","GFR_alpha_1_npx","TNF.R1.npx","PI3_npx", "EFNA4.npx","TNF.R2.npx" ,"DLL1.npx" ,"TNFRSF6B.npx", "CD160.npx","EPHA2.npx","RELT.npx","LTBR.npx","time","status") 

#drop any records with NA
data_drop_na <- data %>% drop_na()    

#Total sample size
nrow(data_drop_na)

#includes all proteins after excluding missing data
x <- data.matrix(data_drop_na[,c("KIM1.npx","SYND1.npx","IL.1RT1.npx","WFDC2.npx","CD27.npx", "TNFRSF10A.npx","LAYN.npx","PVRL4.npx","EDA2R.npx","TNFRSF4.npx","GFR_alpha_1_npx","TNF.R1.npx","PI3_npx", "EFNA4.npx","TNF.R2.npx" ,"DLL1.npx" ,"TNFRSF6B.npx", "CD160.npx","EPHA2.npx","RELT.npx","LTBR.npx")])

#select follow-up time and status
y <- data.matrix(data_drop_na[,c("status")])

#fit the unadjusted logistic regression model
pfit <- glmnet(x, y, family = "binomial")



## ---- Unstardized_plot, echo=TRUE, message=FALSE, warning=FALSE---------------
plot(pfit, label = TRUE) 


## ---- Unstardized_cv_plot, echo=TRUE, message=FALSE, warning=FALSE------------
#fit the cross-validatedmodel
cvfit <- cv.glmnet(x, y, family = "binomial")

plot(pfit, label = TRUE) 


## ---- Unstardized_cv_min, echo=TRUE, message=FALSE, warning=FALSE-------------
#get the minimal lambda value (value of lambda that gives minimum cvm)
cvfit$lambda.min
# Cross-validated logistic regression Model using the minimal lambda
coef(cvfit, s = "lambda.min")


## ---- Unstardized_cv_lse, echo=TRUE, message=FALSE, warning=FALSE-------------
#largest value of lambda such that error is within 1 standard error of the minimum.
cvfit$lambda.lse
# Cross-validated Logistic Regression Model using the lambda.lse
coef(cvfit)


## ---- Adjusted, echo=TRUE, message=FALSE, warning=FALSE-----------------------

#select variables for adjusted model
data2 <- scrambled  %>% select("KIM1.npx","SYND1.npx","IL.1RT1.npx","WFDC2.npx","CD27.npx", "TNFRSF10A.npx","LAYN.npx","PVRL4.npx","EDA2R.npx","TNFRSF4.npx","GFR_alpha_1_npx","TNF.R1.npx","PI3_npx", "EFNA4.npx","TNF.R2.npx" ,"DLL1.npx" ,"TNFRSF6B.npx", "CD160.npx","EPHA2.npx","RELT.npx","LTBR.npx","time","status","BL_eGFR","log10_B_HBA1C_PRC","log10_DU_ACR") 

#drop any records with NA
data_drop_na2 <- data2 %>% drop_na()    

#Total sample size
nrow(data_drop_na2)

#includes all proteins after excluding missing data
x2 <- data.matrix(data_drop_na2[,c("KIM1.npx","SYND1.npx","IL.1RT1.npx","WFDC2.npx","CD27.npx", "TNFRSF10A.npx","LAYN.npx","PVRL4.npx","EDA2R.npx","TNFRSF4.npx","GFR_alpha_1_npx","TNF.R1.npx","PI3_npx", "EFNA4.npx","TNF.R2.npx" ,"DLL1.npx" ,"TNFRSF6B.npx", "CD160.npx","EPHA2.npx","RELT.npx","LTBR.npx","BL_eGFR","log10_B_HBA1C_PRC","log10_DU_ACR")])

#select follow-up time and status
y2 <- data.matrix(data_drop_na2[,c("status")])

#fit the unadjusted logistic regression model
pfit2 <- glmnet(x2, y2, family = "binomial")



## ---- Adjusted_plot, echo=TRUE, message=FALSE, warning=FALSE------------------
plot(pfit2, label = TRUE) 


## ---- Adjusted_cv_plot, echo=TRUE, message=FALSE, warning=FALSE---------------
#fit the cross-validatedmodel
cvfit2 <- cv.glmnet(x2, y2, family = "binomial")

plot(pfit2, label = TRUE) 


## ---- Adjusted_cv_min, echo=TRUE, message=FALSE, warning=FALSE----------------
#get the minimal lambda value (value of lambda that gives minimum cvm)
cvfit2$lambda.min
# Cross-validated Logistic Regression Model using the minimal lambda
coef(cvfit2, s = "lambda.min")


## ---- Adjusted_cv_lse, echo=TRUE, message=FALSE, warning=FALSE----------------
#largest value of lambda such that error is within 1 standard error of the minimum.
cvfit2$lambda.lse
# Cross-validated Logistic Regression Model using the lambda.lse
coef(cvfit2)

