---
title: 'Lasso and Elastic-Net Regularized Generalized Linear Models'
subtitle: 'Logistic Regression Model'
author: "Chunyi Wu and Andrzej Galecki"
date: "`r as.character(Sys.Date(), format = '%A %B %d, %Y')`"
output:
  rmdformats::readthedown: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, data, echo=FALSE, message=FALSE, warning=FALSE}
if (!require('pacman')) install.packages('pacman', repos = "http://cran.us.r-project.org")
library(pacman)

pacman::p_load(
  readxl,       # load excel file
  glmnet,       # Lasso and Elastic-Net Regularized Generalized Linear Models
  rmdformats,   # rmd formats
  rmarkdown,    # rmarkdown
  here,         # File locator
  skimr,        # get overview of data
  tidyverse,    # data management + ggplot2 graphics 
  janitor,      # adding totals and percents to tables
  flextable,    # format the output table
  gtsummary,    # calculate summary statistics and format the results
  sjPlot,       # correlation matrix
  purrr,        # enhances R functional programming (FP) toolki 
  tidyr,        #Tools to help to create tidy data
  ggplot2       #Plot the results
  glmnetUtils   #
  )
```

# Prepare data/matrices 

```{r, prepare-data, echo=TRUE, message=FALSE, warning=FALSE}
#read the data that is stored under the data folder

scrambled<-readRDS(file = "./Data/scrambled.rds")

scrambled <- scrambled  %>% mutate(log10_B_HBA1C_PRC=log10(B_HBA1C_PRC),log10_DU_ACR=log10(DU_ACR))

#select variables for unadjusted model
data <- scrambled  %>% select("KIM1.npx","SYND1.npx","IL.1RT1.npx","WFDC2.npx","CD27.npx", "TNFRSF10A.npx","LAYN.npx","PVRL4.npx","EDA2R.npx","TNFRSF4.npx","GFR_alpha_1_npx","TNF.R1.npx","PI3_npx", "EFNA4.npx","TNF.R2.npx" ,"DLL1.npx" ,"TNFRSF6B.npx", "CD160.npx","EPHA2.npx","RELT.npx","LTBR.npx","time","status") 

#drop any records with NA
data_drop_na <- data %>% drop_na()    

#Total sample size
nrow(data_drop_na)

#includes all proteins after excluding missing data
x <- data.matrix(data_drop_na[,c("KIM1.npx","SYND1.npx","IL.1RT1.npx","WFDC2.npx","CD27.npx", "TNFRSF10A.npx","LAYN.npx","PVRL4.npx","EDA2R.npx","TNFRSF4.npx","GFR_alpha_1_npx","TNF.R1.npx","PI3_npx", "EFNA4.npx","TNF.R2.npx" ,"DLL1.npx" ,"TNFRSF6B.npx", "CD160.npx","EPHA2.npx","RELT.npx","LTBR.npx")])

#select follow-up time and status
y <- data.matrix(data_drop_na[,c("status")])
```

# glmnet for a given $\alpha$

## Fit logistic regression glmnet for a given $\alpha$

* Mixing (hyper)parameter $\alpha$ by default is equal to $1$ (lasso regression)


```{r, Unstardized, echo=TRUE, message=FALSE, warning=FALSE}
#fit the unadjusted(???) logistic regression model
pfit <- glmnet(x, y, family = "binomial")
```

##  Unadjusted(???)  Logistic Regression Model Coefficient Plot

```{r, Unstardized_plot, echo=TRUE, message=FALSE, warning=FALSE}
plot(pfit, label = TRUE) 
```
"Each curve corresponds to a variable. It shows the path of its coefficient against the ${\ell}_1$-norm of the whole 
coefficient vector as $\lambda$ varies. The axis above indicates the number of nonzero coefficients at the current $\lambda$,
which is the effective degrees of freedom (df) for the lasso."

source: ("https://glmnet.stanford.edu/articles/glmnet.html")


# glmnetUtils Glmnet models for multiple alpha 

* We use cross-validation to select a value for $\alpha$.
* The idea of "explicitly control the fold" is implemented in
`glmnetUtils` package

source: (https://glmnet.stanford.edu/articles/glmnet.html)

```{r glmnetUtils}
library(glmnetUtils)
set.seed(46)
alphv <- seq(0, 1, len = 11)^3
cva_pfit <- cva.glmnet(x=x,y=y,family = "binomial",alpha = alphv)
minlossplot(cva_pfit)
```


#  Cross-validation of logistic regression model (Optional)

###  Unadjusted Cross-Validated Logistic Regression Model Coefficient Plot
```{r, Unstardized_cv_plot, echo=TRUE, message=FALSE, warning=FALSE}
#fit the cross-validatedmodel
cvfit <- cv.glmnet(x, y, family = "binomial")

plot(pfit, label = TRUE) 
```

"This plots the cross-validation curve (red dotted line) along with upper and lower standard deviation curves
along the $\lambda$ sequence (error bars). Two special values along the $\lambda$ sequence are indicated by the 
vertical dotted lines. `lambda.min` is the value of $\lambda$ that gives minimum mean cross-validated error, 
while `lambda.1se` is the value of $\lambda$ that gives the most regularized model such that the cross-validated 
error is within one standard error of the minimum."

source: ("https://glmnet.stanford.edu/articles/glmnet.html")

###   minimal lambda value

###  Unadjusted Cross-Validated Logistic Regression Coefficients using the minimal lambda value 
```{r, Unstardized_cv_min, echo=TRUE, message=FALSE, warning=FALSE}
#get the minimal lambda value (value of lambda that gives minimum cvm)
cvfit$lambda.min
# Cross-validated logistic regression Model using the minimal lambda
coef(cvfit, s = "lambda.min")
```

##   - lambda.lse
####  Unadjusted Cross-Validated Logistic Regression Coefficients using lambda.lse
```{r, Unstardized_cv_lse, echo=TRUE, message=FALSE, warning=FALSE}
#largest value of lambda such that error is within 1 standard error of the minimum.
cvfit$lambda.lse
# Cross-validated Logistic Regression Model using the lambda.lse
coef(cvfit)
```

## Adjusted Logistic Regression Model 

### Adjusted Logistic Regression Model (adjusting for Baseline HbA1c, ACR, eGFR)
```{r, Adjusted, echo=TRUE, message=FALSE, warning=FALSE}

#select variables for adjusted model
data2 <- scrambled  %>% select("KIM1.npx","SYND1.npx","IL.1RT1.npx","WFDC2.npx","CD27.npx", "TNFRSF10A.npx","LAYN.npx","PVRL4.npx","EDA2R.npx","TNFRSF4.npx","GFR_alpha_1_npx","TNF.R1.npx","PI3_npx", "EFNA4.npx","TNF.R2.npx" ,"DLL1.npx" ,"TNFRSF6B.npx", "CD160.npx","EPHA2.npx","RELT.npx","LTBR.npx","time","status","BL_eGFR","log10_B_HBA1C_PRC","log10_DU_ACR") 

#drop any records with NA
data_drop_na2 <- data2 %>% drop_na()    

#Total sample size
nrow(data_drop_na2)

#includes all proteins after excluding missing data
x2 <- data.matrix(data_drop_na2[,c("KIM1.npx","SYND1.npx","IL.1RT1.npx","WFDC2.npx","CD27.npx", "TNFRSF10A.npx","LAYN.npx","PVRL4.npx","EDA2R.npx","TNFRSF4.npx","GFR_alpha_1_npx","TNF.R1.npx","PI3_npx", "EFNA4.npx","TNF.R2.npx" ,"DLL1.npx" ,"TNFRSF6B.npx", "CD160.npx","EPHA2.npx","RELT.npx","LTBR.npx","BL_eGFR","log10_B_HBA1C_PRC","log10_DU_ACR")])

#select follow-up time and status
y2 <- data.matrix(data_drop_na2[,c("status")])

#fit the unadjusted logistic regression model
pfit2 <- glmnet(x2, y2, family = "binomial")

```

##   - coefficient plot
####  Adjusted Logistic Regression Model Coefficient Plot
```{r, Adjusted_plot, echo=TRUE, message=FALSE, warning=FALSE}
plot(pfit2, label = TRUE) 
```

##   - cross-validated logistic regression model
####  Adjusted Cross-Validated Logistic Regression Model Coefficient Plot
```{r, Adjusted_cv_plot, echo=TRUE, message=FALSE, warning=FALSE}
#fit the cross-validatedmodel
cvfit2 <- cv.glmnet(x2, y2, family = "binomial")

plot(pfit2, label = TRUE) 
```

##   - minimal lambda value
####  Adjusted Cross-Validated Logistic Regressionn Coefficients using minimal lambda value
```{r, Adjusted_cv_min, echo=TRUE, message=FALSE, warning=FALSE}
#get the minimal lambda value (value of lambda that gives minimum cvm)
cvfit2$lambda.min
# Cross-validated Logistic Regression Model using the minimal lambda
coef(cvfit2, s = "lambda.min")
```

##   - lambda.lse
####  Adjusted Cross-Validated Logistic Regression Coefficients using lambda.lse
```{r, Adjusted_cv_lse, echo=TRUE, message=FALSE, warning=FALSE}
#largest value of lambda such that error is within 1 standard error of the minimum.
cvfit2$lambda.lse
# Cross-validated Logistic Regression Model using the lambda.lse
coef(cvfit2)
```